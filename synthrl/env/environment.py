import os
import sys
# Abstract class that all environment classes should inherit
# class Environment:
#   def __init__(self):
#     raise NotImplementedError
  
#   def trainstion(self, action=None): #To Us, Transtion is deterministic
#     raise NotImplementedError

#   def rest(self):
#     raise NotImplementedError
class ListEnv:

  '''
  Following rule lists composes action space
  '''




  hole=["HOLE"]
   
  def __init__(self):
    pass
  
  def is_valid_sate(): #This method will characterize State Space
    '''
    Each State is (pp,pp',E)
      - pp parital program of Synthesizer     // 
      - pp' partial program of Verifier      //
      - E: Colleciton of Test cases         // 
    Each State wiil be defiend as dict().
    '''
    pass  
  def is_valid_action():
    pass
  def transition():
    pass

class Tree:
  def __init__(self,data,children=list()):
    self.data=data
    self.children=children

  def append_children(self,new_children):
    self.children.extend(new_children)

  def __repr__(self):
    return 'Tree(%s, %s)' % (self.data, self.children)

  def traverse(self, target_data):
    if self.data==target_data:        
      return self
    else:
      for child in (self.children):
        if child.data==target_data:
          return child
        elif len(child.children)>0: 
          child.traverse(target_data)
    return None
  
  def is_child_exist(self,target_data):
    for child in self.children:
      if child.data==target_data:
        return child
    return None    



       

class ListProgram(Tree):
  insts_rules     =["assign","assign_high", "assign_first_input", "assign_second_input","end"]
  func_rules      =["head" ,"last" ,"take" ,"drop" ,"access" ,"minimum" ,"maximum" ,"reverse" ,"sort" ,"sum"]
  high_func_rules =["map","filter","count","zipwit","scanl1"] 
  var_rules       =["a" , "b" , "c" , "d" , "e" , "f" , "h" , "i" , "j" ,"k" ,"l" ,"m" , "n" , "p"] + ["o"]
  #For moments a variable being used for arugment 
  arugments_rules =["a" , "b" , "c" , "d" , "e" , "f" , "h" , "i" , "j" ,"k" ,"l" ,"m" , "n" , "p"] + ["x","y"]
  intint_rules    =[ "(+1)","(-1)" ,"(*2)" ,"(/2)","(*(-1))" ,"(**2)","(*3)","(/3)","(*4)","(/4)"]
  intbool_rules   =["(>0)" ,"(<0)"  ,"(%2==0)"  ,"(%2==1)"]
  intintint_rules =["(+)", "(-)"   ,"(*)"   ,"MIN"   ,"MAX"]

  #I will set data of each node in tree as Dictionary to involve:
  # which is
  #{
  #   Name of Production Rule (Variable) :  ____,
  #   The Token Generated by Upper Production Rule: ____,
  # }

  def __init__(self,data,children=list()):
    super().__init__(data,children)
  
  def production_inst(self,action):
    if action=="assign":
      self.append_children( [Tree({"VAR":"HOLE"}), Tree({"FUNC":"HOLE"})])
    elif action=="assign_first_input" :
      self.append_children([Tree({"VAR":"HOLE"}), Tree({"VAR":"x"})] )
    elif action=="assign_first_input" :
      self.append_children([Tree({"VAR":"HOLE"}), Tree({"VAR":"y"})] )

  def production_func(self,action):
    if action=="head":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "HEAD"}
      current_node.children=[Tree({"VAR":"HOLE"})]
    elif action=="last":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "LAST"}
      current_node.children=[Tree({"VAR":"HOLE"})]
    elif action=="take":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "TAKE"}
      current_node.children=[Tree({"VAR":"HOLE"}),Tree({"VAR":"HOLE"})]
    elif action=="drop":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "DROP"}
      current_node.children=[Tree({"VAR":"HOLE"}),Tree({"VAR":"HOLE"}) ]
    elif action=="access":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "ACCESS"}
      current_node.children=[Tree({"VAR":"HOLE"}),Tree({"VAR":"HOLE"}) ]
    elif action=="minimum":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "MINIMUM"}
      current_node.children=[Tree({"VAR":"HOLE"})]
    elif action=="maximum":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "MAXIMUM"}
      current_node.children=[Tree({"VAR":"HOLE"})]
    elif action=="reverse":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "REVERSE"}
      current_node.children=[Tree({"VAR":"HOLE"})]
    elif action=="sort":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "SORT"}
      current_node.children=[Tree({"VAR":"HOLE"})]
    elif action=="sum":
      current_node = self.traverse({"FUNC" : "HOLE"})
      current_node.data={"FUNC" : "SUM"}
      current_node.children=[Tree({"VAR":"HOLE"})]

  def production_arg(self,arg_var):
    for x in self.func_rules:
      current_node = self.traverse({"FUNC" : x.upper()})
      if current_node != None:
        target_child =current_node.is_child_exist({"VAR":"HOLE"})
        if target_child != None:
          target_child.data={"VAR":arg_var}
  
  def production_var_assign(self,var):    
    for insts in self.children:
      if insts.data=={"VAR":"HOLE"}:
        insts.data={"VAR":"z"}
        return
    
    

current=ListProgram({"START": "start"})
current.production_inst("assign")
current.production_func("head")
current.production_arg("a")
current.production_var_assign("z")



print(current)